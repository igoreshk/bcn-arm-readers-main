package com.epam.beacons.cloud.monitor.service.service;

import com.epam.beacons.cloud.monitor.service.domain.TrilaterationData;
import com.epam.beacons.cloud.monitor.service.domain.VisitorDto;
import java.util.ArrayList;
import java.util.List;
import org.apache.commons.math3.fitting.leastsquares.LeastSquaresFactory;
import org.apache.commons.math3.fitting.leastsquares.LeastSquaresOptimizer;
import org.apache.commons.math3.fitting.leastsquares.LeastSquaresOptimizer.Optimum;
import org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem;
import org.apache.commons.math3.fitting.leastsquares.LevenbergMarquardtOptimizer;
import org.apache.commons.math3.linear.Array2DRowRealMatrix;
import org.apache.commons.math3.linear.ArrayRealVector;
import org.apache.commons.math3.linear.DiagonalMatrix;
import org.apache.commons.math3.linear.RealMatrix;
import org.apache.commons.math3.linear.RealVector;
import org.apache.commons.math3.util.Pair;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

/**
 * Calculate coordinates according to
 * <a href="https://kb.epam.com/display/EPMLSTR/Trilateration">trilateration algorithm</a>.
 **/
@Component
public class TrilaterationSolver {

    private static class ReaderData {

        private final double latitude;
        private final double longitude;
        private final double distance;

        public ReaderData(double latitude, double longitude, double distance) {
            this.latitude = latitude;
            this.longitude = longitude;
            this.distance = distance;
        }

        public double getLatitude() {
            return latitude;
        }

        public double getLongitude() {
            return longitude;
        }

        public double getDistance() {
            return distance;
        }

    }

    private static final double DISTANCE_LOWER_LIMIT = 1.0E-7D;
    private static final double LOG_BASE = 10;
    private static final int MAX_EVALUATIONS = 1500;
    private static final int MAX_ITERATIONS = 1500;

    private final LeastSquaresOptimizer leastSquaresOptimizer = new LevenbergMarquardtOptimizer();
    private final double multiplier;
    private final double power;
    private final double addon;

    public TrilaterationSolver(
            @Value("${beacons.cloud.trilateration.coefficientOne}") double multiplier,
            @Value("${beacons.cloud.trilateration.coefficientTwo}") double power,
            @Value("${beacons.cloud.trilateration.coefficientThree}") double addon
    ) {
        this.multiplier = multiplier;
        this.power = power;
        this.addon = addon;
    }

    /**
     * Calculates position of the visitor {@link VisitorDto} based on data {@link TrilaterationData}
     * using reader location and a signal strength to the reader generated by positioning device of
     * the visitor.
     *
     * @param trilaterationData collection of {@link TrilaterationData} for trilateration
     * @return object that describe a current location of the visitor
     */
    public double[] trilaterate(List<TrilaterationData> trilaterationData) {
        List<ReaderData> readerData = new ArrayList<>();
        for (TrilaterationData data : trilaterationData) {
            double distance = Math.max(computeDistance(data.getReferencePower(), data.getRssi()), DISTANCE_LOWER_LIMIT);
            readerData.add(new ReaderData(data.getLatitude(), data.getLongitude(), distance));
        }
        double[] target = new double[readerData.size()];
        double[] weights = new double[target.length];
        double[] initialPoint = new double[2];

        for (int i = 0; i < readerData.size(); ++i) {
            ReaderData data = readerData.get(i);
            target[i] = 0.0D;
            weights[i] = inverseSquareLaw(data.getDistance());
            initialPoint[0] += data.getLatitude();
            initialPoint[1] += data.getLongitude();
        }
        initialPoint[0] /= readerData.size();
        initialPoint[1] /= readerData.size();

        LeastSquaresProblem leastSquaresProblem = LeastSquaresFactory.create(
                point -> createJacobian(readerData, point),
                new ArrayRealVector(target, false),
                new ArrayRealVector(initialPoint, false),
                new DiagonalMatrix(weights),
                null, MAX_EVALUATIONS, MAX_ITERATIONS
        );
        // Optimizes a received longitude and latitude according to
        // https://en.wikipedia.org/wiki/Least_squares
        Optimum optimum = leastSquaresOptimizer.optimize(leastSquaresProblem);

        return optimum.getPoint().toArray();
    }

    /**
     * Implements <a href="https://en.wikipedia.org/wiki/Inverse-square_law">Inverse Square law</a> stating that a
     * specified physical quantity is inversely proportional to the square of the distance from the source of that
     * physical quantity.
     */
    private double inverseSquareLaw(double distance) {
        return 1.0D / (distance * distance);
    }

    public double computeDistance(int referencePower, int rssi) {
        if (Double.compare(referencePower, 0) == 0) {
            throw new IllegalArgumentException("Reference power can not be zero");
        }
        double ratio = rssi * 1.0 / referencePower;
        if (Double.compare(ratio, 1) < 0) {
            return Math.pow(ratio, LOG_BASE);
        } else {
            return multiplier * Math.pow(ratio, power) + addon;
        }
    }

    private Pair<RealVector, RealMatrix> createJacobian(List<ReaderData> readerData, RealVector point) {
        double[] coordinate = point.toArray();
        double[] functionValues = new double[readerData.size()];
        double[][] jacobian = new double[readerData.size()][coordinate.length];

        for (int i = 0; i < readerData.size(); ++i) {
            ReaderData data = readerData.get(i);
            // Least squares approximation
            functionValues[i] += Math.pow(coordinate[0] - data.getLatitude(), 2.0D);
            functionValues[i] += Math.pow(coordinate[1] - data.getLongitude(), 2.0D);
            functionValues[i] -= Math.pow(data.getDistance(), 2.0D);

            jacobian[i][0] = 2.0D * (coordinate[0] - data.getLatitude());
            jacobian[i][1] = 2.0D * (coordinate[1] - data.getLongitude());
        }
        return new Pair<>(new ArrayRealVector(functionValues), new Array2DRowRealMatrix(jacobian));
    }
}
